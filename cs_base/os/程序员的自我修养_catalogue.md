## 第1部分 简介

## 第1章 温故而知新

1.1 从HELLO WORLD 说起

1.2 万变不离其宗

1.3 站得高，望得远

1.4 操作系统做什么

1.5 内存不够怎么办

1.6 众人拾柴火焰高

1.7 本章小结

## 第2部分 静态链接

## 第2章 编译和链接

2.1 被隐藏了的过程

2.2 编译器做了什么

2.3 链接器年龄比编译器长

2.4 模块拼装——静态链接

2.5 本章小结

## 第3章 目标文件里有什么

3.1 目标文件的格式

3.2 目标文件是什么样的

3.3 挖掘SIMPLESECTION.O

3.4 ELF 文件结构描述

3.5 链接的接口——符号

3.6 调试信息

3.7 本章小结

## 第4章 静态链接

4.1 空间与地址分配

4.2 符号解析与重定位

4.3 COMMON 块

4.4 C++相关问题

4.5 静态库链接

4.6 链接过程控制

4.7 BFD 库

4.8 本章小结

## 第5章 WINDOWS PE/COFF

5.1 WINDOWS 的二进制文件格式PE/COFF 134

5.2 PE 的前身——COFF

5.3 链接指示信息

5.4 调试信息

5.5 大家都有符号表

5.6 WINDOWS 下的ELF——PE

5.7 本章小结

## 第3部分 装载与动态链接

## 第6章 可执行文件的装载与进程

6.1 进程虚拟地址空间

6.2 装载的方式

6.3 从操作系统角度看可执行文件的装载

6.4 进程虚存空间分布

6.5 LINUX 内核装载ELF 过程简介

6.6 WINDOWS PE 的装载

6.7 本章小结

## 第7章 动态链接

7.1 为什么要动态链接

7.2 简单的动态链接例子

7.3 地址无关代码

7.4 延迟绑定（PLT）

7.5 动态链接相关结构

7.6 动态链接的步骤和实现

7.7 显式运行时链接

7.8 本章小结

## 第8章 LINUX 共享库的组织

8.1 共享库版本

8.2 符号版本

8.3 共享库系统路径

8.4 共享库查找过程

8.5 环境变量

8.6 共享库的创建和安装

8.7 本章小结

## 第9章 WINDOWS 下的动态链接

9.1 DLL 简介

9.2 符号导出导入表

9.3 DLL 优化

9.4 C++与动态链接

9.5 DLL HELL

9.6 本章小结

## 第4部分 库与运行库

## 第10章 内存

10.1 程序的内存布局

10.2 栈与调用惯例

10.3 堆与内存管理

10.4 本章小结

## 第11章 运行库

11.1 入口函数和程序初始化

11.2 C/C++运行库

11.3 运行库与多线程

11.4 C++全局构造与析构

11.5 FREAD 实现

11.6 本章小结

## 第12章 系统调用与API

12.1 系统调用介绍

12.2 系统调用原理

12.3 WINDOWS API

12.4 本章小结

## 第13章 运行库实现

13.1 C 语言运行库

13.2 如何使用MINI CRT

13.3 C++运行库实现

13.4 如何使用MINI CRT++

13.5 本章小结

附录A

A.1 字节序（BYTE ORDER）

A.2 ELF 常见段

A.3 常用开发工具命令行参考








