
## 元编程

### 构建系统

您需要定义依赖、目标和规则。您必须告诉构建系统您具体的构建目标，系统的任务则是找到构建这些目标所需要的依赖，并根据规则构建所需的中间产物，直到最终目标被构建出来

make 是最常用的构建系统之一, 当您执行 make 时，它会去参考当前目录下名为 Makefile 的文件。所有构建目标、相关依赖和规则都需要在该文件中定义.

    paper.pdf: paper.tex plot-data.png
      pdflatex paper.tex

    plot-%.png: %.dat plot.py
      ./plot.py -i $*.dat -o $@

冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖。缩进的部分是从依赖构建目标时需要用到的一段程序

在 make 中，第一条指令还指明了构建的目的，如果您使用不带参数的 make，这便是我们最终的构建结果

规则中的 % 是一种模式，它会匹配其左右两侧相同的字符串

再次执行 make ,make回去检查之前的构建是因其依赖改变而需要被更新.

makefiles 都提供了 一个名为 clean 的构建目标，可以使用它清理文件，让 make 重新构建

### 依赖管理

语义版本号： 主版本号.次版本号.补丁号。相关规则有：

如果新的版本没有改变 API，请将补丁号递增；

如果您添加了 API 并且该改动是向后兼容的，请将次版本号递增；

如果您修改了 API 但是它并不向后兼容，请将主版本号递增。

**锁文件（lock files）**

锁文件列出了您当前每个依赖所对应的具体版本号

极端的依赖锁定叫做 vendoring，它会把您的依赖中的所有代码直接拷贝到您的项目中

### 持续集成系统

持续集成，或者叫做 CI 是一种雨伞术语（umbrella term）。比较大的有 Travis CI、Azure Pipelines 和 GitHub Actions。

工作原理都是类似的：您需要在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对

最常见的规则是：如果有人提交代码，执行测试套。当这个事件被触发时，CI 提供方会启动一个（或多个）虚拟机，执行您制定的规则，并且通常会记录下相关的执行结果。CI 会自动帮我们处理后续的事情。

**测试简介**

测试套：所有测试的统称

单元测试：一个“微型测试”，用于对某个封装的特性进行测试

集成测试：: 一个“宏观测试”，针对系统的某一大部分进行，测试其不同的特性或组件是否能协同工作。

回归测试：用于保证之前引起问题的 bug 不会再次出现

模拟（Mocking）: 使用一个假的实现来替换函数、模块或类型，屏蔽那些和测试不相关的内容。例如，您可能会“模拟网络连接” 或 “模拟硬盘”


## 大杂烩

###  





