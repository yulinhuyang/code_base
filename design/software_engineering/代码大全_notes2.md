# 第三部分 变量

## 第10章 使用变量的一般事项

利用构建活动来填补需求和架构中存在的细小间隙是一种行之有效的做法;但把蓝图设计得精细到已经能完全展现出所有的细节则实在是一种低效的方法
尽量缩小变量的作用域，尽量缩短变量的生存时间 ——Tacey

基础数据类型：见图
 
核对表（使用数据的一般事项）

初始化变量
* 每一个子程序都检查其输入参数的正确性了吗？
* 变量声明位置靠近变量第一次使用的位置吗？
* 尽可能地在声明变量的同时初始化变量了吗？
* 如果无法同时声明和初始化变量，有没有在靠近第一次使用变量的位置声明变量？
* 计数器和累加器经过了适当的初始化了吗？如果需要再一次使用，之前重新初始化了吗？
* 适当的重新初始化“需要重复执行的代码里的变量”了吗？
* 代码在通过编译器编译的时候是不是没有警告信息？（你启用了所有可用的警告选项了吗？）
* 如果你用的语言允许隐式声明，你为此可能引发的问题做好补偿措施了吗？
* 一次性初始化所有具名常量：可用可执行代码初始化之

使用数据的其他事项
* 如果可能，所有变量都被定义为具有最小的作用域了吗？
* 各变量的引用点都尽可能集中在一起了吗？对同一变量的两次相邻引用，或者变量的整个生命周期都这样做了吗？
* 控制结构符合数据类型吗？
* 所有生命的变量都用到了吗？
* 变量都在合适的时间绑定了吗？——也就是说，你有意识地在晚期绑定所带来的灵活性和增加的复杂度之间做出平衡了吗？
* 每个变量都有且仅有一项用途吗？
* 每个变量的含义都很明确且没有隐含含义吗？


要点
* 数据初始化过程很容易出错，使用上面初始化方法来避免由于非预期的初始化值而造成的错误。
* 最小化每个变量的作用域。把同一变量的引用点集中在一起。把变量限定在子程序或类的范围之内。避免使用全局数据。
* 把使用相同变量的语句尽可能集中在一起
* 早起绑定会减低灵活性，但有助于减小复杂度。晚期绑定可以增加灵活性，同时增加复杂度
* 把每个变量用于唯一用途

## 第11章 变量名的力量

为变量取好的名字和高效编程同样重要
变量名要完全、准确地描述出该变量所代表的的事物
变量名的适宜长短和变量的作用域相关，越局部的变量，变量名越短（如循环变量）

常用对仗词： 见图
 
核对表（变量命名）

命名的一般注意事项
* 名字完整并准确地表带了变量所代表的含义吗？
* 名字反映了显示世界的问题而不是编程语言方案吗？
* 名字足够长，可以让你无需苦苦思索吗？
* 如果有计算值限定符，它被放在名字的最后吗？
* 名字中用Count或者Index来代替Num了吗？

为特定类型的数据命名
* 循环下表的名字有意义吗（如果循环的长度超过了一两行代码或者出现了全套循环，那么就应该是i、j或者k以外的其他名字）？
* 所有的“”临时“”变量都重新命以更有意义的名字了吗？
* 当布尔变量的值为真时，变量名能准确表达其含义吗？
* 枚举类型的名字中含有能够表示其类别的前缀和后缀了吗？例如，把Color_用于Clolor_Red、Color_Blue了吗？
* 具名常量是根据它所代表的抽象实体而不是他说代表的数字来命名了吗?

命名规则
* 规则能够区分局部数据、类的数据和全局数据吗？
* 规则能够区分类型名、具名常量、枚举类型和变量名吗？
* 规则能够在编译器不强制检测只读参数的语言里标识出子程序中的输入参数吗？
* 规则尽可能的与语言的标准规则兼容吗？
* 名字为了可读性而加以格式化吗？

短名字
* 代码用了长名字吗（除非有必要使用短名字）？
* 是否避免只为了省一个字符而缩写名字的情况？
* 所有单词的缩写方式都一致吗？
* 名字能够读出来吗？
* 避免使用容易被看错或者读错的名字吗？
* 在缩写对照表里对短名字做出说明吗？

常见命名问题：你应该避免使用：
* 容易让人误解的名字
* 有相近含义的名字
* 只有一两个字符不同的名字
* 发音相近的名字
* 包含数字的名字
* 为了缩短而故意拼错的名字
* 英语中经常拼错的名字吗
* 与标准库子程序名或者预定义变量名冲突的名字
* 过于随意的名字
* 含有难读的字符的名字
要点
* 好的变量名是提高程序可读性的一项关键要素。对特殊种类的变量，比如循环下表和状态变量，需要加以特殊的考虑
* 名字要尽可能的具体。那些台模糊或者太通用以至于能够用于多种目的的名字通常都是很不好的
* 命名规则应该能够区分局部数据、类数据和全局数据。他们还应该可以区分类型名、具名常量、枚举类型名字和变量名。
* 无论哪种类型项目，你都应该采用某种变量命名规则。你所采用的规则的种类取决于你的程序的规模，以及项目成员的人数。
* 现代编程语言很少需要用到缩写。如果你真的要是用缩写，请使用项目缩写词典或者标准前缀来帮助理解缩写
* 代码阅读的次数远远多于编写的次数。确保你所取得名字更侧重于阅读方便而不是编写方便

##第12章  基本数据类型

核对表：基本数据类型

数值概论
* 代码中避免使用神秘数值
* 代码考虑了除零错误了吗？
* 类型转换很明显吗？
* 如果在一条语句中存在两个不同类型的变量，那么这条语句会想你期望的那样求值吗？
* 代码避免了混合类型比较吗？
* 程序编译时没有警告信息吗？

整数
* 使用整数除法的表达式能按预期的那样工作吗？
* 整数表达式避免整数溢出问题吗？

浮点数
* 代码避免了对数量级相差巨大的数字做加减运算吗？
* 代码系统地阻止了舍入错误的发生吗？
* 代码避免对对浮点数做灯亮比较吗？

字符和字符串
* 代码避免使用神秘字符串和神秘字符了吗？
* 使用字符串时避免了off-by-one错误了吗？
* C代码吧字符串指针和字符数组区别对待了吗？
* C代码遵循了把字符串声明为CONTANT+1长度了吗？
* C代码在适当的时候用字符数组来代替指针了吗？
* C代码吧字符串初始化为NULL来避免无终端的字符串了吗？
* C代码用strncpy()代替strcpy()吗？strncat()和strncmp()呢？

布尔变量
* 程序用额外的布尔变量来说明条件判断了吗？
* 程序用额外的布尔变量来简化条件判断了吗？

枚举类型
* 程序用枚举类型而非具名常量来提高可读性、可靠性、和可修改性了吗？
* 当变量的用法不能仅用true和false表示的时候，程序用枚举类型取代布尔变量吗？
* 针对枚举类型的测试检测了非法数值吗？
* 把枚举类型的第一项条目保留为“非法“了吗？

具名常量
* 程序用具名常量而不是神秘数值来声明数据和表示循环界限了吗？
* 具名常量的使用一致吗？——没有在有些位置使用具名常量又在其它位置使用文字量？

数组
* 所有的数组下标都没有超出数组边界吗?
* 数组引用没有出现off-by-one错误吗？
* 所有多维数组的下标的顺序都正确吗？
* 在嵌套循环里，把正确的变量用于数组下标来避免循环下标串话了吗？

创建类型
* 程序对每一种可能变化的数据分别采用不同的类型吗？
* 类型名是以该类型所表示的显示世界实体为导向，而不是以编程语言类型为导向吗？
* 类型名的描述性足以强，可以帮助解释数据声明吗？
* 你避免重新定义预定义类型吗？
* 与简单的重定义一个类型相比，你考虑过创建一个新类吗?

要点
* 使用特定的数据类型就意味着要记住适用于各个类型的很多独立的原则。用本章的核对表来确认你已经对常见问题做了考虑。
* 如果你的语言支持，创建自定义类型会使得你的程序更容易修改，并更具有自描述性
* 当你用typedef或者其等价方式创建了一个简单类型的时候，考虑是否更应该创建一个新的类


## 第13章  不常见的数据类型


只有万不得已时才使用全局数据
！！！就近原则！！！注释紧随代码，变量紧随使用它们的地方 ——Tacey

访问器子程序的优势
* 你获得了对数据的集中控制
* 你可以确保对变量的所有引用都得到了保护
* 自动获取信息隐藏的普遍益处
* 访问器子程序可以很容易转变为抽象数据类型

**如何使用访问器子程序**
* 要求所有的代码通过访问器子程序来存储数据：比如，所有全局以g_开头，除了访问器，其他代码都不得访问
* 不要把所有的全局数据都扔在一处：尽量把全局数据和访问器子程序打包到适合的类里面
* 用锁定来控制对全局变量的访问：锁定要求使用或者更新一个全局变量值之前，该变量必须被签出，完成使用之后再签入。（加锁）
* 在访问器子程序里构建一个抽象层
* 对一项数据的所有访问都应该在同一个层次上（操作一致性）

降低全局数据的风险：
* 创建一种命名规则来突出全局变量
* 为全部的全局变量创建一份注释良好的清单
* 不要用全局变量来存放中间结果
* 不要把所有的数据都放在一个大对象中并导出传递，以说明你没有使用全局变量

核对表（使用不常见数据类型的注意事项）

结构体
* 你使用结构体而不是使用单纯的变量来组织和操作相关的数据吗？
* 你考虑创建一个类来代替使用结构体吗？

**全局数据**
* 所有的变量是否都是局部的或者是类范围的？除非绝对必要才是全局的？
* 变量的命名规则能把局部数据、类数据和全局数据区分开吗？
* 你对所有的全局变量都加以文档说明吗？
* 避免使用伪全局数据，即被四处传递且包含有杂乱数据的巨大对象吗？
* 用访问子程序来取代全局数据吗？
* 把访问子程序和数据组织到类里面吗？
* 访问器子程序提供了一个在底层数据类型实现之上的抽象层吗？
* 所有相关的访问器子程序都位于同一抽象层吗？

**指针**
* 把指针操作隔离在子程序里吗？
* 指针引用合法吗？或者说指针有可能成为空悬指针吗？
* 代码在使用指针之前检查他的有效性吗？
* 在使用指针所指向的变量之前检查其有效性吗？
* 指针用完后被设置为空值吗？
* 就可读性而言，代码用了所有需要使用的指针变量吗？
* 链表中的指针是按正确的顺序加以释放吗？
* 程序分配了一片保留的内存后备区域，一遍在耗尽内存的时候能够优雅地退出吗？
* 是不是在没有其他方法可用的情况下最终才使用指针的？

**要点**
* 结构体可以使得程序更简单、更容易理解，以及更容易维护
* 每当你打算使用结构体的时候，考虑采用类是不是会工作的更好。
* 指针很容易出错。用访问子程序或类以及防御式编程实践来保护自己的代码。
* 避免使用全局变量，不只是因为它们危险，还是因为你可以用其他更好的方法取代它们。
* 如果你不得不使用全局变量，那么就通过访问子程序来使用它。访问器子程序能为你带来全局变量所能带来的一切优点，还有一些额外的好处。






