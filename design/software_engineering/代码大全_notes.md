
# 第一部分：打好基础

## 第一章：欢迎进入软件构建的世界

首先要明确开发计算机软件是一个复杂的工程，并不比建设高楼大厦简单。这项活动和传统的土木工程类有相似的部分，也有迥然不同的地方。

主要有下面的几种活动（根据进程推动顺序）：

- 定义问题
- 需求分析
- 规划构建
- 软件架构/高层设计
- 详细设计
- 编码与调试
- 单元测试
- 集成测试
- 系统测试
- 部署/分发及保障维护
	
《代码大全》主要关注的是构建这部分：

软件构建是软件开发的核心活动；构建活动是每个项目中位移一项必不可少的工作

软件构建的主要活动包括：详细设计、编码、调试、集成、开发者测试（包括单元测试和集成测试）

构建也被称作“编码”和“编程”

构建活动的质量对软件的质量有着实质性的影响

最后，你对“如何进行构建”的理解程度，决定了你这名"程序员"的优秀程度


## 第二章：用隐喻来更充分地理解软件开发

	隐喻的价值绝不应该被低估。隐喻的优点在于其预期的效果：能被所有的人理解。不必要的沟通和误解也因此大为降低，学习与教授更为快速。实际上，隐喻是对概念进行内在化和抽象的一种途径，
	它让人在更高的层面上思考问题，从而避免低层次的错误。

隐喻是启示而不是算法，因此他们往往有一点随意。

隐喻把软件开发过程与其他你熟悉的活动联系在一起，帮助你更好地理解

有些隐喻比其他一些隐喻更贴切

通过把软件的构建过程比作是房屋的建设过程，我们可以发现，仔细的准备是必要的，而大型项目和小型项目之间也是有差异的

通过把软件开发中的实践比作是只会工具箱中的工具，我们发现，每位程序员都有许多工具，但并不存在任何一个能适用于所有工作的工具，因地制宜地选择正确工具是成为能有效编程的程序员的关键。

不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合。

隐喻是以一种类比的方法根据一种已知的“模型范式”去理解一种新的领域。这很符合人类认知新事物的思维习惯。但隐喻不是神话，更不是精确的真理，就像某个比喻一样只能在某一个局部进行双向的类比，未必就是全局最合适的。
（同时，注意比喻是有局部性的，不是全局可逆的）

## 第三章：三思而后行：前期准备

	问题定义只定义了问题是什么，而不涉及任何可能的解决方案。

	如果没有好的需求，你可能对问题有总体的把握，但却没有集中问题的特定方面。

	需求像水。如果冻结了，就容易在上面开展建设 ——无名氏 （经常性无法预期的需求变更会伤害项目的开发者，从而毁了项目）

	软件架构是软件设计的高层部分，适用于支撑更细节的设计的框架。

	离开了良好的软件架构，你可能瞄准了正确的问题，但却使用了错误的解决方案。也许完全不可能有成功的构建。

**架构的典型组成部分**

	程序组织 （源代码层级）
	主要的类 2/8原则 （基础占20%）
	数据设计 （数据建模）
	业务规则 （很有现实意义的重点）
	用户界面设计 （用户使用的友好度）
	资源管理
	安全性（数据库连接、线程、句柄等） （甚至更广泛层面的权限管理）
	性能
	可伸缩性
	互用性
	国际化、本地化
	输入输出
	错误处理
	容错性
	架构的可行性
	过渡工程
	关于买和造的决策 （在现实情况下，买现成的方案也许是一种更优的选择，不可耻）
	关于复用的决策
	变更策略
	架构的总体质量

**要点**

	构建活动的准备工作的根本目标在于降低风险。要确认你的准备活动是在降低风险，而非增加风险
	如果你想开发高质量的软件，软件开发过程必须由始至终关注质量。在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的一项要大
	程序员的一部分工作是教育老板和合作者，告诉他们软件开发过程，包括在开始编程之前进行充分准备的重要性
	你所从事的软件项目的类型对构建活动的前期准备有重大影响——许多项目应该是高度迭代的，某些应该是序列式的
	如果没有明确的问题定义，那么你可能会在构建期间解决错误的问题
	如果没有做完良好的需求分析工作，你可能没有察觉待解决的问题的重要细节。如果需求变更发生在构建之后的阶段，其代价是“在项目早期更改需求”的20-100倍。因此在开始编程之前，你要确认“需求“已经到位了
	如果没有做完良好的架构设计，你可能会在构建期间用错误的方法解决正确的问题。架构变更的代价随着“为错误的架构编写的代码数量”增加而增加，因此，也要确认“”架构“”已经到位了。
	理解项目的前期准备所采用的方法，并相应地选择构建方法。

**核对表**

架构核对表

针对各架构主题

	程序的整体组织结构是否清晰？是否包含一个良好的架构全局观（及其理由）
	是否确定了主要得到构造快（包括每个构造快的职责范围及与其他构造快的接口）
	是否明确涵盖了“需求”中所列出的所有功能（每个功能对应的构造快不太多也不太少）
	是否描述并论证了那些最关键的类
	是否描述并论证了数据设计
	是否详细定义了数据库的组织结构和内容
	是否指出了所用关键的业务规则，并描述其对系统的影响？
	是否描述了用户界面设计的策略‘
	是否将用户界面模块化，使界面的变更不会影响程序其余部分
	是否描述并论证了处理I/O的策略
	是否估算了稀缺资源（如现成、数据库连接、句柄、网络带宽、存储及算力等）的使用量，是否描述并论证了资源管理的策略
	是否描述了架构的安全需求
	架构是否为每个类、每个子系统、每个模块功能域提出空间与时间预算
	架构是否描述了如何达到可伸缩性
	架构是否关注互操作性
	是否描述了国际化本地化的策略 （这个要看具体的项目，比如一个团队内部使用的工具，完全没必要，但如果既往框架对此有支持而又没有明显的增加工作量也可以考虑其后续在这方面的扩展性）
	是否提供了一套内聚的错误处理策略
	是否规定了容错的方法
	是否证实了系统各个部分的技术可行性
	是否详细描述了过渡工程的方法
	是否包含了必要的 买 vs. 造的决策
	架构是否描述了如何加工复用的代码，使之符合其他架构目标？
	是否将架构设计得能够适应和可能出现的变更
	
架构的总体质量

	架构是否解决了全部的需求
	有没有那个部分是过渡架构或欠架构？是否明确宣布了在这方面的预期指标
	整个架构是否在概念上协调一致
	顶层设计是否独立于用作实现它的机器和语言
	是否说明了所有主要的决策和动机
	你，作为一名实现该系统的程序员，是否对这个架构感觉良好？	

## 第四章：关键的“构建”决策

核对表：主要的构建实践

编码

* 你有没有确定多少设计工作将要预先进行，多少设计工作在键盘上进行（在编写代码的同事）？
* 你有没有规定诸如名称、注释、代码格式等“编码约定” （编码规范）
* 你有没有规定特定的由软件架构确定的编码实践，比如如何处理错误条件，如何处理安全性事项，对于类接口有哪些约定、可重用的代码遵循哪些标准，在编码实考虑多少性能因素
* 你有没有找到自己在技术浪潮中的位置，并相应调整自己的措施？如果必要，你是否知道如何“深入一种语言去编程”，而不受限于语言*（仅仅“在一种语言上编程”）

团队工作

* 你有没有定义一套集成工序——即，你有没有定义一套特定的步骤，规定程序员在把代码check in（签入）到主源码（代码库）中之前，必须履行这些步骤
* 程序员是结对编程、还是独自编程，或者这二者的某种组合

质量保证

* 程序员在编写代码之前，是否先为之编写测试用例 （测试驱动）
* 程序员会为自己的代码写单元测试吗？（无论先写还是后写）
* 程序员在check in 代码之前，会调用调试器但不追踪整个代码流程吗？
* 程序员在check in 代码之前，是否进行集成测试（integration-test）
* 程序员会复审（review）或检查别人的代码吗?	

工具

* 你是否选用了某种版本控制工具 （svn，git）
* 你是否选定了一种语言，以及语言的版本或编译器版本
* 你是否选择了某个编程框架（framework,如j2ee 、。net）,或者明确地决定不使用编程框架
* 你是否决定允许使用非标准的语言特性？（在使用非标准的情况下，要保证其整体迁移能力，比如hack了某一部分，要将其整体实现包括到项目内）
* 你是否选定并拥有了其他将要用到的工具——编辑器、重构工具、调试器、测试框架、语法检查器？

要点

-  每种编程语言都有其优点和弱点。要知道你使用的语言的明确优点和弱点
-  在开始编程之前，做好一些约定。“改变代码”使之符合这些“约定”是几乎不可能的
-  “构建的实践方法”的种类比任何单个项目能用到的要多。有意识地选择最适合你的项目的时间方法
-  问问你自己，你采用的编程实践是对你所用的编程语言的正确响应，还是受它的控制？清记得“深入一种语言去编程”，不要仅“在一种语言上编程”
-  你在技术浪潮中的位置决定了哪种方法是有效的——甚至是可能用到的。确定你在技术浪潮中的位置，并响应调整计划和预期目标

