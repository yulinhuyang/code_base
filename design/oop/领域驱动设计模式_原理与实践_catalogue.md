# 第Ⅰ部分 领域驱动设计的原则与实践

## 第1章 什么是领域驱动设计  

1.1 为复杂问题域创建软件的挑战  

1.1.1 未使用通用语言创建的代码  

1.1.2 组织结构的缺乏  

1.1.3 泥球模式将扼杀开发  

1.1.4 缺乏对问题域的关注  

1.2 领域驱动设计模式如何管理复杂性  

1.2.1 DDD的战略模式  

1.2.2 DDD的战术模式  

1.2.3 问题空间与解空间  

1.3 领域驱动设计的实践与原则  

1.3.1 专注于核心领域  

1.3.2 通过协作进行学习  

1.3.3 通过探索和实验来创建模型  

1.3.4 通信  

1.3.5 理解模型的适用性  

1.3.6 让模型持续发展  

1.4 领域驱动设计的常见误区  

1.4.1 战术模式是DDD的关键  

1.4.2 DDD是一套框架  

1.4.3 DDD是一颗灵丹妙药  

1.5 要点  

## 第2章 提炼问题域  

2.1 知识提炼与协作  

2.1.1 通过通用语言达成共识  

2.1.2 领域知识的重要性  

2.1.3 业务分析员的角色  

2.1.4 一个持续过程  

2.2 与领域专家一起获得领域见解  

2.2.1 领域专家与业务相关人员的对比  

2.2.2 对于业务的更深刻理解  

2.2.3 与你的领域专家互动  

2.3 有效提炼知识的模式    

2.3.1专注在最有意思的对话上  

2.3.2从用例开始  

2.3.3提出有力的问题  

2.3.4草图  

2.3.5CRC卡  

2.3.6延迟对模型中概念的命名  

2.3.7行为驱动开发  

2.3.8快速成型  

2.3.9查看基于纸面的系统  

2.4查看现有模型  

2.4.1理解意图  

2.4.2事件风暴  

2.4.3影响地图  

2.4.4理解业务模型  

2.4.5刻意发现  

2.4.6模型探讨漩涡  

2.5要点  

## 第3章专注于核心领域  

3.1为何要分解一个问题域  

3.2如何捕获问题的实质  

3.2.1超越需求  

3.2.2为达成什么是核心内容的共识而捕获领域愿景  

3.3如何专注于核心问题  

3.3.1提炼问题域  

3.3.2核心领域  

3.3.3将你的核心领域当作一款产品而非一个项目  

3.3.4通用域   

3.3.5支撑域  

3.4子域如何决定解决方案的形成  

3.5并非一个系统的所有部分都会经过良好设计  

3.5.1专注于清晰边界而非完美模型  

3.5.2一开始核心领域不必总是需要是完美的  

3.5.3构建用于替代而非重用的子域  

3.6如果没有核心领域怎么办  

3.7要点  

## 第4章模型驱动设计  

4.1什么是领域模型  

4.1.1领域与领域模型的对比  

4.1.2分析模型  

4.1.3代码模型  

4.1.4代码模型是领域模型的主要表现  

4.2模型驱动设计  

4.2.1预先设计的挑战  

4.2.2团队建模  

4.3使用通用语言将分析和代码模型绑定在一起  

4.3.1语言的生存周期将大于软件  

4.3.2业务语言  

4.3.3开发人员和业务之间的转译  

4.4基于通用语言进行协作  

4.4.1通过使用具体示例来定制出语言  

4.4.2教导你的领域专家专注在问题上而不要跳到解决方案  

4.4.3塑造语言的最佳实践  

4.5如何创建有效的领域模型  

4.5.1不要让实情妨碍一个好模型  

4.5.2仅对相关内容建模  

4.5.3领域模型都是暂时有用的  

4.5.4要十分清楚专业术语  

4.5.5限制你的抽象  

4.6何时应用模型驱动设计  

4.6.1如果它不值得花费精力，则不要尝试对其建模  

4.6.2专注于核心领域  

4.7要点  

## 第5章领域模型实现模式  

5.1领域层  

5.2领域模型实现模式  

5.2.1领域模型  

5.2.2事务脚本  

5.2.3表模块  

5.2.4活动记录  

5.2.5贫血领域模型  

5.2.6贫血领域模型和函数编程  

5.3要点  

## 第6章使用有界上下文维护领域模型的完整性  

6.1单个模型的挑战  

6.1.1模型的复杂性可能会增加  

6.1.2多个团队处理单个模型  

6.1.3模型语言中的歧义  

6.1.4领域概念的适用范围  

6.1.5集成遗留代码或第三方代码  

6.1.6领域模型并非企业模型  

6.2使用有界上下文划分和破除大模型  

6.2.1定义模型的边界  

6.2.2子域和有界上下文之间的差异  

6.3实现有界上下文  

6.4要点  

## 第7章上下文映射  

7.1一个现实情况的映射  

7.1.1技术的现实  

7.1.2组织的现实  

7.1.3映射一个相关现实情况  

7.1.4用X标记核心领域的位置  

7.2认识有界上下文之间的关系  

7.2.1防止损坏层  

7.2.2共享内核  

7.2.3开放宿主服务  

7.2.4分道扬镳  

7.2.5合作关系  

7.2.6一种上游/下游关系  

7.3传递上下文映射  

7.4上下文映射的战略重要性 

7.4.1保持完整性 

7.4.2解决计划的基础 

7.4.3理解所有权和职责 

7.4.4揭示业务工作流中的混乱区域 

7.4.5识别非技术障碍 

7.4.6鼓励良好的沟通 

7.4.7帮助加入的新员工 

7.5要点 

## 第8章应用程序架构 

8.1应用程序架构 

8.1.1分离应用程序的问题 

8.1.2从领域的复杂性中进行抽象 

8.1.3分层架构 

8.1.4依赖倒置 

8.1.5领域层 

8.1.6应用程序服务层 

8.1.7基础架构层 

8.1.8跨层通信 

8.1.9隔离测试 

8.1.10不要在有界上下文之间共享数据结构 

8.1.11应用程序架构与用于有界上下文的架构的对比 

8.2应用程序服务 

8.2.1应用程序逻辑与领域逻辑的对比 

8.2.2定义和公开能力 

8.2.3业务用例协作 

8.2.4应用程序服务表示的是用例，而不是创建、读取、更新和删除 

8.2.5作为实现详情的领域层 

8.2.6领域报告 

8.2.7读取模型与事务模型的对比 

8.3应用程序客户端 

8.4要点 

## 第9章团队开始应用领域驱动设计通常会遇到的问题 

9.1过分强调战术模式的重要性 

9.1.1将相同架构用于所有的有界上下文 

9.1.2力求战术模式尽善尽美 

9.1.3错误估计构造块对于DDD的价值 

9.1.4专注于代码而非DDD的原则 

9.2缺失了DDD的真实价值：协作、通信和上下文 

9.2.1由于低估上下文的重要性而产生大泥球 

9.2.2未能成功创建UL将造成歧义和误解 

9.2.3由于缺乏协作将只能设计专注于技术的解决方案 

9.3在不重要的部分花费太多时间 

9.4简单问题复杂化 

9.4.1将DDD原则应用到具有少量业务预期的琐碎领域 

9.4.2别将CRUD作为反模式 

9.4.3将领域模型模式用于每一个有界上下文 

9.4.4问一问自己：额外的复杂性是否值得 

9.5低估应用DDD的成本 

9.5.1尝试在没有积极专注的团队的情况下取得成功 

9.5.2项目背后没有领域专家时的协作尝试 

9.5.3在非迭代式开发方法中进行学习 

9.5.4将DDD应用到每一个问题 

9.5.5为不必要的纯粹性而牺牲实用主义 

9.5.6寻求验证会浪费精力 

9.5.7永远力求代码之美 

9.5.8DDD关乎的是提供价值 

9.6要点 

## 第10章应用DDD的原则、实践与模式 

10.1推广使用DDD 

10.1.1培训团队 

10.1.2与业务人员进行交流 

10.2应用DDD的原则 

10.2.1理解愿景 

10.2.2捕获所需的行为 

10.2.3理解环境的现实情况 

10.2.4对解决方案建模 

10.3探究和实验 

10.3.1质疑假设 

10.3.2建模是一项持续性活动 

10.3.3不存在错误的模型 

10.3.4灵活的代码有助于探索发现 

10.4让隐式内容变得显式 

10.4.1处理歧义 

10.4.2为事物命名 

10.5问题解决人先行，技术专家后行 

10.6如何才能知道我在正确地工作 

10.6.1好用就足够了 

10.6.2实践、实践、实践 

10.7要点 

# 第Ⅱ部分 战略模式：在有界上下文之间通信

## 第11章 有界上下文集成介绍 

11.1如何集成有界上下文 

11.1.1有界上下文是独立自主的 

11.1.2在代码层面集成有界上下文的挑战 

11.1.3使用物理边界来强制实现整洁的模型 

11.1.4集成遗留系统 

11.2集成分布式有界上下文 

11.2.1集成用于分布式有界上下文的策略 

11.2.2数据库集成 

11.2.3平面文件集成 

11.2.4RPC 

11.2.5消息传递 

11.2.6REST 

11.3DDD使用分布式系统的挑战 

11.4分布式事务将损害可扩展性和可靠性 

11.4.1有界上下文不必彼此保持一致 

11.4.2最终一致性 

11.5事件驱动响应式DDD 

11.5.1展示响应式解决方案的弹性和可扩展性 

11.5.2异步消息传递的挑战和取舍 

11.5.3RPC还有价值吗 

11.6SOA和响应式DDD 

11.6.1将你的有界上下文视作SOA服务 

11.6.2进一步处理微服务架构 

11.7要点 

## 第12章通过消息传递集成 

12.1消息传递基础 

12.1.1消息总线 

12.1.2可靠的消息传递 

12.1.3存储转发 

12.1.4命令和事件 

12.1.5最终一致性 

12.2使用NServiceBus构建一个电子商务应用程序 

12.2.1系统设计 

12.2.2从Web应用程序发送命令 

12.2.3处理命令和发布事件 

12.2.4使用消息传递网关让外部HTTP调用变得可靠 

12.2.5实践中的最终一致性 

12.2.6有界上下文会存储其本地所需的所有数据 

12.2.7把所有内容都放在UI中 

12.3维护消息传递应用程序 

12.3.1消息版本管理 

12.3.2监控和扩展 

12.4将有界上下文与公共传输集成 

12.4.1消息传递桥 

12.4.2公共传输 

12.5要点 

##  第13章通过使用RPC和REST的HTTP来集成 

13.1为何选用HTTP 

13.1.1没有平台耦合 

13.1.2每个人都理解HTTP 

13.1.3大量的成熟工具和库 

13.1.4内部测试你的API 

13.2RPC 

13.2.1在HTTP上实现RPC 

13.2.2选择一种RPC风格 

13.3REST 

13.3.1深入浅出地解释REST 

13.3.2用于有界上下文集成的REST 

13.3.3维护REST应用程序 

13.3.4将REST用于有界上下文集成的缺点 

13.4要点 

# 第Ⅲ部分 战术模式：创建有效的领域模型

## 第14章 构造块领域建模介绍 

14.1战术模式 

14.2对领域建模的模式 

14.2.1实体 

14.2.2值对象 

14.2.3领域服务 

14.2.4模块 

14.3生命周期模式 

14.3.1聚合 

14.3.2工厂 

14.3.3存储库 

14.4显露模式 

14.4.1领域事件 

14.4.2事件溯源 

14.5要点 

## 第15章 值对象 

15.1何时使用值对象 

15.1.1表示描述性的、欠缺身份的概念 

15.1.2增强明确性 

15.2定义特征 

15.2.1欠缺身份 

15.2.2基于特性的相等性 

15.2.3富含行为 

15.2.4内聚 

15.2.5不可变 

15.2.6可组合性 

15.2.7自验证 

15.2.8可测试 

15.3常见的建模模式 

15.3.1静态工厂方法 

15.3.2微类型 

15.3.3规避集合 

15.4持久化 

15.4.1NoSQL 

15.4.2SQL 

15.5要点 

## 第16章 实体 

16.1 理解实体 

16.1.1具有身份和连贯性的领域概念 

16.1.2上下文依赖 

16.2实现实体 

16.2.1分配标识符 

16.2.2将行为推入到值对象和领域服务中 

16.2.3验证并强制不变性 

16.2.4专注于行为，而非数据 

16.2.5避免“建模现实世界”的谬误 

16.2.6分布式设计 

16.3常见的实体建模原则和模式 

16.3.1使用规范实现验证和不变条件 

16.3.2避免状态模式；使用显式建模  

16.3.3避免将接收器和设置器与备忘录模式结合使用 

16.3.4选用无隐藏意外影响的功能 

16.4要点 

## 第17章 领域服务 

17.1理解领域服务 

17.1.1何时使用领域服务 

17.1.2领域服务解析 

17.1.3避免使用贫血领域模型 

17.1.4与应用程序服务对比 

17.2利用领域服务 

17.2.1服务层中 

17.2.2领域中 

17.3要点 

## 第18章 领域事件 

18.1领域事件模式的实质 

18.1.1已经发生了的重要领域事件 

18.1.2响应事件 

18.1.3可选的异步性 

18.1.4内部事件与外部事件对比 

18.2事件处理操作 

18.2.1调用领域逻辑 

18.2.2调用应用程序逻辑 

18.3领域事件的实现模式 

18.3.1使用.Net框架的事件模型 

18.3.2使用内存中的总线 

18.3.3UdiDahan的DomainEvents静态类 

18.3.4返回领域事件 

18.3.5使用IoC容器作为事件分发器 

18.4测试领域事件 

18.4.1单元测试 

18.4.2应用服务层测试 

18.5要点 

## 第19章聚合 

19.1管理复杂对象图形 

19.1.1选用单一遍历方向 

19.1.2合格的关联关系 

19.1.3选用ID而不是对象引用 

19.2聚合 

19.2.1围绕领域不变条件进行设计 

19.2.2高层次的领域抽象 

19.2.3一致性边界 

19.2.4选用较小的聚合 

19.3定义聚合边界 

19.3.1eBidder：在线拍卖案例研究 

19.3.2与不变条件保持一致 

19.3.3与事务和一致性保持一致 

19.3.4忽略用户界面影响 

19.3.5避免无用的集合与容器 

19.3.6不要专注于HAS-A关系 

19.3.7重构聚合 

19.3.8满足业务用例——非现实环境 

19.4实现聚合 

19.4.1选择一个聚合根 

19.4.2引用其他聚合 

19.4.3实现持久化 

19.4.4实现事务一致性 

19.4.5实现最终一致性 

19.4.6实现并发性 

19.5要点 

## 第20章工厂 

20.1工厂的作用 

20.1.1从构造中分离出应用 

20.1.2封装内部事物 

20.1.3隐藏创建类型的决策 

20.1.4聚合上的工厂方法 

20.1.5用于重构的工厂 

20.1.6务实地使用工厂 

20.2要点 

## 第21章存储库 

21.1存储库 

21.2一种被误解的模式 

21.2.1存储库是一种反模式吗 

21.2.2领域模型和持久化模型之间的区别 

21.2.3通用存储库 

21.3聚合持久化策略 

21.3.1使用能在不损坏领域模型的情况下将其映射到数据模型的持久化框架 

21.3.2使用不能在不影响领域模型的情况下直接映射它的持久化框架 

21.3.3公共接收器和设置器 

21.3.4使用备忘录模式 

21.3.5事件流 

21.3.6求真务实 

21.4存储库是一个明确的约定 

21.5事务管理和工作单元 

21.6保存或不保存 

21.6.1持久化追踪领域对象变更的框架 

21.6.2必须将变更显式保存到聚合 

21.7充当防止损坏层的存储库 

21.8存储库的其他职责 

21.8.1实体ID生成 

21.8.2集合汇总 

21.8.3并发性 

21.8.4审计追踪 

21.9存储库反模式 

21.9.1反模式：不要支持即席查询 

21.9.2反模式：延迟加载是一种设计异味 

21.9.3反模式：不要为了报告需要而使用存储库 

21.10存储库实现 

21.10.1持久化框架可以在不损坏领域模型的情况下将其映射到数据模型 

21.10.2持久化框架不能在不损坏领域模型的情况下直接映射领域模型 

21.11要点 

## 第22章事件溯源 

22.1将状态存储为快照的限制 

22.2通过将状态存储为事件流来获得竞争优势 

22.2.1时态查询 

22.2.2投影 

22.2.3快照 

22.3源自事件的聚合 

22.3.1构造 

22.3.2持久化与再融合 

22.4构建一个事件存储 

22.4.1设计一种存储格式 

22.4.2创建事件流 

22.4.3附加到事件流 

22.4.4查询事件流 

22.4.5添加快照支持 

22.4.6管理并发性 

22.4.7一个基于SQLServer的事件存储 

22.4.8构建你自己的事件存储是一个好主意吗 

22.5使用专门构建的EventStore 

22.5.1安装GregYoung的EventStore 

22.5.2使用C#客户端库 

22.5.3运行时态查询 

22.5.4创建投影 

22.6使用事件溯源的CQRS 

22.6.1使用投影创建视图缓存 

22.6.2CQRS和事件溯源协作 

22.7简要复述事件溯源的好处 

22.7.1竞争性业务优势 

22.7.2专注于表述性行为的聚合 

22.7.3简化的持久化 

22.7.4更好的调试 

22.8衡量事件溯源的代价 

22.8.1版本控制 

22.8.2要学习的新概念和要磨练的技能 

22.8.3需要学习和掌握的新技术 

22.8.4大量的数据存储需求 

22.9额外的学习资源 

22.10要点 

# 第Ⅳ部分有效应用程序的设计模式

## 第23章应用程序用户界面的架构设计 

23.1设计考量 

23.1.1占有式UI与构成式UI的对比 

23.1.2HTMLAPI与数据API的对比 

23.1.3客户端与服务器端聚合/协作对比 

23.2示例1：用于非分布式有界上下文的一个基于HTMLAPI的、服务器端的UI 

23.3示例2：用于分布式有界上下文的一个基于数据API的客户端UI 

23.4要点 

## 第24章CQRS：一种有界上下文的架构 

24.1为两个上下文维护单个模型的挑战 

24.2用于复杂有界上下文的一种更好的架构 

24.3命令端：业务任务 

24.3.1显式建模意图 

24.3.2不受展现干扰所影响的模型 

24.3.3处理业务请求 

24.4查询端：领域报告 

24.4.1直接映射到数据模型的报告 

24.4.2从领域事件中构建的具体化视图 

24.5对CQRS的误解 

24.5.1CQRS很难 

24.5.2CQRS是最终一致的 

24.5.3模型需要源自事件 

24.5.4命令应该是异步的 

24.5.5CQRS仅适用于消息传递系统 

24.5.6需要将CQRS用于领域事件 

24.6可以扩展应用程序的模式 

24.6.1扩展读取端：一个最终一致的读取模型 

24.6.2扩展写入端：使用异步命令 

24.6.3对一切进行扩展 

24.7要点 

## 第25章 命令：用于处理业务用例的应用程序服务模式 

25.1区分应用程序逻辑和领域逻辑 

25.1.1应用程序逻辑 

25.1.2来自应用程序服务角度的领域逻辑 

25.2应用程序服务模式 

25.2.1命令处理程序 

25.2.2发布/订阅 

25.2.3请求/回复模式 

25.2.4async/await 

25.3测试应用程序服务 

25.3.1使用领域专业术语 

25.3.2测试尽可能多的功能 

25.4要点 

## 第26章 查询：领域报告 

26.1有界上下文中的领域报告 

26.1.1从领域对象中派生报告 

26.1.2直接访问数据存储 

26.1.3从事件流构建投影 

26.2跨有界上下文的领域报告 

26.2.1复合UI 

26.2.2单独的报告上下文 

26.3要点  [2]


