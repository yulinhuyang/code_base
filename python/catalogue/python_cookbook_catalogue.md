**第1章 数据结构和算法** 

1.1 将序列分解为单独的变量 

1.2 从任意长度的可迭代对象中分解元素 

1.3 保存最后N个元素 

1.4 找到最大或最小的N个元素 

1.5 实现优先级队列 

1.6 在字典中将键映射到多个值上 

1.7 让字典保持有序 

1.8 与字典有关的计算问题 

1.9 在两个字典中寻找相同点 

1.10 从序列中移除重复项且保持元素间顺序不变

1.11 对切片命名 

1.12 找出序列中出现次数最多的元素 

1.13 通过公共键对字典列表排序 

1.14 对不原生支持比较操作的对象排序

1.15 根据字段将记录分组 

1.16 筛选序列中的元素 

1.17 从字典中提取子集 

1.18 将名称映射到序列的元素中 

1.19 同时对数据做转换和换算

1.20 将多个映射合并为单个映射 

**第2章 字符串和文本**

2.1 针对任意多的分隔符拆分字符串

2.2 在字符串的开头或结尾处做文本匹配

2.3 利用Shell通配符做字符串匹配

2.4 文本模式的匹配和查找 

2.5 查找和替换文本 

2.6 以不区分大小写的方式对文本做查找和替换

2.7 定义实现最短匹配的正则表达式

2.8 编写多行模式的正则表达式

2.9 将Unicode文本统一表示为规范形式

2.10 用正则表达式处理Unicode字符

2.11 从字符串中去掉不需要的字符

2.12 文本过滤和清理

2.13 对齐文本字符串

2.14 字符串连接及合并

2.15 给字符串中的变量名做插值处理

2.16 以固定的列数重新格式化文本

2.17 在文本中处理HTML和XML实体

2.18 文本分词

2.19 编写一个简单的递归下降解析器

2.20 在字节串上执行文本操作

**第3章 数字、日期和时间**

3.1 对数值进行取整

3.2 执行精确的小数计算

3.3 对数值做格式化输出 

3.4 同二进制、八进制和十六进制数打交道

3.5 从字节串中打包和解包大整数

3.6 复数运算

3.7 处理无穷大和NaN 

3.8 分数的计算

3.9 处理大型数组的计算 

3.10 矩阵和线性代数的计算 

3.11 随机选择 

3.12 时间换算 

3.13 计算上周5的日期 

3.14 找出当月的日期范围 

3.15 将字符串转换为日期 

3.16 处理涉及到时区的日期问题 

**第4章 迭代器和生成器** 

4.1 手动访问迭代器中的元素 

4.2 委托迭代 

4.3 用生成器创建新的迭代模式 

4.4 实现迭代协议 

4.5 反向迭代 

4.6 定义带有额外状态的生成器函数 

4.7 对迭代器做切片操作 

4.8 跳过可迭代对象中的前一部分元素 

4.9 迭代所有可能的组合或排列 

4.10 以索引-值对的形式迭代序列 

4.11 同时迭代多个序列 

4.12 在不同的容器中进行迭代 

4.13 创建处理数据的管道 

4.14 扁平化处理嵌套型的序列 

4.15 合并多个有序序列，再对整个有序序列进行迭代 

4.16 用迭代器取代while循环 

**第5章 文件和I/O** 

5.1 读写文本数据 

5.2 将输出重定向到文件中 

5.3 以不同的分隔符或行结尾符完成打印 

5.4 读写二进制数据 

5.5 对已不存在的文件执行写入操作 

5.6 在字符串上执行I/O操作 

5.7 读写压缩的数据文件 

5.8 对固定大小的记录进行迭代 

5.9 将二进制数据读取到可变缓冲区中 

5.10 对二进制文件做内存映射 

5.11 处理路径名 

5.12 检测文件是否存在 

5.13 获取目录内容的列表 

5.14 绕过文件名编码 

5.15 打印无法解码的文件名 

5.16 为已经打开的文件添加或修改编码方式 

5.17 将字节数据写入文本文件 

5.18 将已有的文件描述符包装为文件对象 

5.19 创建临时文件和目录 

5.20 同串口进行通信 

5.21 序列化Python对象 

**第6章 数据编码与处理** 

6.1 读写CSV数据 

6.2 读写JSON数据 

6.3 解析简单的XML文档 

6.4 以增量方式解析大型XML文件 

6.5 将字典转换为XML 

6.6 解析、修改和重写XML 

6.7 用命名空间来解析XML文档 

6.8 同关系型数据库进行交互 

6.9 编码和解码十六进制数字 

6.10 Base64编码和解码 

6.11 读写二进制结构的数组 

6.12 读取嵌套型和大小可变的二进制结构 

6.13 数据汇总和统计 

**第7章 函数** 

7.1 编写可接受任意数量参数的函数 

7.2 编写只接受关键字参数的函数 

7.3 将元数据信息附加到函数参数上 

7.4 从函数中返回多个值 

7.5 定义带有默认参数的函数 

7.6 定义匿名或内联函数 

7.7 在匿名函数中绑定变量的值 

7.8 让带有N个参数的可调用对象以较少的参数形式调用 

7.9 用函数替代只有单个方法的类 

7.10 在回调函数中携带额外的状态 

7.11 内联回调函数 

7.12 访问定义在闭包内的变量 

**第8章 类与对象** 

8.1 修改实例的字符串表示 

8.2 自定义字符串的输出格式 

8.3 让对象支持上下文管理协议 

8.4 当创建大量实例时如何节省内存 

8.5 将名称封装到类中 

8.6 创建可管理的属性 

8.7 调用父类中的方法 

8.8 在子类中扩展属性 

8.9 创建一种新形式的类属性或实例属性 

8.10 让属性具有惰性求值的能力 

8.11 简化数据结构的初始化过程 

8.12 定义一个接口或抽象基类 

8.13 实现一种数据模型或类型系统 

8.14 实现自定义的容器 

8.15 委托属性的访问 

8.16 在类中定义多个构造函数 

8.17 不通过调用init来创建实例 

8.18 用Mixin技术来扩展类定义 

8.19 实现带有状态的对象或状态机 

8.20 调用对象上的方法，方法名以字符串形式给出 

8.21 实现访问者模式 

8.22 实现非递归的访问者模式 

8.23 在环状数据结构中管理内存 

8.24 让类支持比较操作 

8.25 创建缓存实例 

**第9章 元编程** 

9.1 给函数添加一个包装 

9.2 编写装饰器时如何保存函数的元数据 

9.3 对装饰器进行解包装 

9.4 定义一个可接受参数的装饰器 

9.5 定义一个属性可由用户修改的装饰器 

9.6 定义一个能接收可选参数的装饰器 

9.7 利用装饰器对函数参数强制执行类型检查 

9.8 在类中定义装饰器 

9.9 把装饰器定义成类 

9.10 把装饰器作用到类和静态方法上 

9.11 编写装饰器为被包装的函数添加参数 

9.12 利用装饰器给类定义打补丁 

9.13 利用元类来控制实例的创建 

9.14 获取类属性的定义顺序 

9.15 定义一个能接受可选参数的元类 

9.16 在*args和**kwargs上强制规定一种参数签名 

9.17 在类中强制规定编码约定 

9.18 通过编程的方式来定义类 

9.19 在定义的时候初始化类成员 

9.20 通过函数注解来实现方法重载 

9.21 避免出现重复的属性方法 

9.22 以简单的方式定义上下文管理器 

9.23 执行带有局部副作用的代码 

9.24 解析并分析Python源代码 

9.25 将Python源码分解为字节码 

**第10章 模块和包** 

10.1 把模块按层次结构组织成包 

10.2 对所有符号的导入进行精确控制 

10.3 用相对名称来导入包中的子模块 

10.4 将模块分解成多个文件 

10.5 让各个目录下的代码在统一的命名空间下导入 

10.6 重新加载模块 

10.7 让目录或zip文件成为可运行的脚本 

10.8 读取包中的数据文件 

10.9 添加目录到sys.path中 

10.10 使用字符串中给定的名称来导入模块 

10.11 利用import钩子从远端机器上加载模块 

10.12 在模块加载时为其打补丁 

10.13 安装只为自己所用的包 

10.14 创建新的Python环境 

10.15 发布自定义的包 

**第11章 网络和Web编程** 

11.1 以客户端的形式同HTTP服务交互 

11.2 创建一个TCP服务器 

11.3 创建一个UDP服务器 

11.4 从CIDR地址中生成IP地址的范围 

11.5 创建基于REST风格的简单接口 

11.6 利用XML-RPC实现简单的远端过程调用 

11.7 在不同的解释器间进行通信 

11.8 实现远端过程调用 

11.9 以简单的方式验证客户端身份 

11.10 为网络服务增加SSL支持 

11.11 在进程间传递socket文件描述符 

11.12 理解事件驱动型I/O 

11.13 发送和接收大型数组 

**第12章 并发** 

12.1 启动和停止线程 

12.2 判断线程是否已经启动 

12.3 线程间通信 

12.4 对临界区加锁 

12.5 避免死锁 

12.6 保存线程专有状态 

12.7 创建线程池 

12.8 实现简单的并行编程 

12.9 如何规避GIL带来的限制 

12.10 定义一个Actor任务 

12.11 实现发布者/订阅者消息模式 

12.12 使用生成器作为线程的替代方案 

12.13 轮询多个线程队列 

12.14 在UNIX上加载守护进程 

**第13章 实用脚本和系统管理** 

13.1 通过重定向、管道或输入文件来作为脚本的输入 

13.2 终止程序并显示错误信息 

13.3 解析命令行选项 

13.4 在运行时提供密码输入提示 

13.5 获取终端大小 

13.6 执行外部命令并获取输出 

13.7 拷贝或移动文件和目录 

13.8 创建和解包归档文件 

13.9 通过名称来查找文件 

13.10 读取配置文件 

13.11 给脚本添加日志记录 

13.12 给库添加日志记录 

13.13 创建一个秒表计时器 

13.14 给内存和CPU使用量设定限制 

13.15 加载Web浏览器 

**第14章 测试、调试以及异常** 

14.1 测试发送到stdout上的输出 

14.2 在单元测试中为对象打补丁 

14.3 在单元测试中检测异常情况 

14.4 将测试结果作为日志记录到文件中 

14.5 跳过测试，或者预计测试结果为失败 

14.6 处理多个异常 

14.7 捕获所有的异常 

14.8 创建自定义的异常 

14.9 通过引发异常来响应另一个异常 

14.10 重新抛出上一个异常 

14.11 发出告警信息 

14.12 对基本的程序崩溃问题进行调试 

14.13 对程序做性能分析以及计时统计 

14.14 让你的程序运行得更快 

**第15章 C语言扩展** 

15.1 利用ctypes来访问C代码 

15.2 编写简单的C语言扩展模块 

15.3 编写一个可操作数组的扩展函数 

15.4 在C扩展模块中管理不透明指针 

15.5 在扩展模块中定义并导出C API 

15.6 从C中调用Python 

15.7 在C扩展模块中释放GIL 

15.8 混合使用C和Python环境中的线程 

15.9 用Swig来包装C代码 

15.10 用Cython来包装C代码 

15.11 用Cython来高效操作数组 

15.12 把函数指针转换为可调用对象 

15.13 把以NULL结尾的字符串传给C库 

15.14 把Unicode字符串传递给C库 

15.15 把C字符串转换到Python中 

15.16 同编码方式不确定的C字符串打交道 

15.17 把文件名传给C扩展模块 

15.18 把打开的文件传给C扩展模块 

15.19 在C中读取文件型对象 

15.20 从C中访问可迭代对象 

15.21 排查段错误




