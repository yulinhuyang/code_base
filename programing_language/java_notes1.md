
[Effective Java, Third Edition](https://www.jianshu.com/c/ce8cf0e13b23)

https://github.com/sjsdfg/effective-java-3rd-chinese

https://sjsdfg.github.io/effective-java-3rd-chinese/#/


[effective Java 读书笔记](https://www.zybuluo.com/caos/note/44777)



## 第2章　创建和销毁对象 

### 第1条：用静态工厂方法代替构造器  

### 第2条：遇到多个构造器参数时要考虑使用构建器  

### 第3条：用私有构造器或者枚举类型强化Singleton属性 

### 第4条：通过私有构造器强化不可实例化的能力 

### 第5条：优先考虑依赖注入来引用资源  

### 第6条：避免创建不必要的对象  

### 第7条：消除过期的对象引用  

### 第8条：避免使用终结方法和清除方法  

### 第9条：try-with-resources优先于try-finally  

## 第3章　对于所有对象都通用的方法  

### 第10条：覆盖equals时请遵守通用约定  

### 第11条：覆盖equals时总要覆盖hashCode  

### 第12条：始终要覆盖toString  

### 第13条：谨慎地覆盖clone  

### 第14条：考虑实现Comparable接口  

## 第4章　类和接口  

### 第15条：使类和成员的可访问性最小化  

### 第16条：要在公有类而非公有域中使用访问方法  

### 第17条：使可变性最小化  

### 第18条：复合优先于继承  

### 第19条：要么设计继承并提供文档说明，要么禁止继承  

### 第20条：接口优于抽象类  

### 第21条：为后代设计接口  

### 第22条：接口只用于定义类型  

### 第23条：类层次优于标签类  

### 第24条：静态成员类优于非静态成员类  

### 第25条：限制源文件为单个顶级类  

## 第5章　泛型  

### 第26条：请不要使用原生态类型  

### 第27条：消除非受检的警告  

### 第28条：列表优于数组  

### 第29条：优先考虑泛型  

### 第30条：优先考虑泛型方法  

### 第31条：利用有限制通配符来提升API的灵活性  

### 第32条：谨慎并用泛型和可变参数  

### 第33条：优先考虑类型安全的异构容器  

## 第6章　枚举和注解  

### 第34条：用enum代替int常量  

### 第35条：用实例域代替序数  

### 第36条：用EnumSet代替位域  

### 第37条：用EnumMap代替序数索引  

### 第38条：用接口模拟可扩展的枚举  

### 第39条：注解优先于命名模式  

### 第40条：坚持使用Override注解  

### 第41条：用标记接口定义类型  

## 第7章　Lambda和Stream  

### 第42条：Lambda优先于匿名类  

### 第43条：方法引用优先于Lambda  

### 第44条：坚持使用标准的函数接口  

### 第45条：谨慎使用Stream  

### 第46条：优先选择Stream中无副作用的函数  

### 第47条：Stream要优先用Collection作为返回类型  

### 第48条：谨慎使用Stream并行  

## 第8章　方法  

### 第49条：检查参数的有效性  

### 第50条：必要时进行保护性拷贝  

### 第51条：谨慎设计方法签名  

### 第52条：慎用重载  

### 第53条：慎用可变参数  

### 第54条：返回零长度的数组或者集合，而不是null  

### 第55条：谨慎返回optinal  

### 第56条：为所有导出的API元素编写文档注释  

## 第9章　通用编程  

### 第57条：将局部变量的作用域最小化  

### 第58条：for-each循环优先于传统的for循环  

### 第59条：了解和使用类库  

### 第60条：如果需要精确的答案，请避免使用float和double  

### 第61条：基本类型优先于装箱基本类型  

### 第62条：如果其他类型更适合，则尽量避免使用字符串  

### 第63条：了解字符串连接的性能  

### 第64条：通过接口引用对象  

### 第65条：接口优先于反射机制  
 
### 第66条：谨慎地使用本地方法  

### 第67条：谨慎地进行优化  

### 第68条：遵守普遍接受的命名惯例  

## 第10章　异常  

### 第69条：只针对异常的情况才使用异常  

### 第70条：对可恢复的情况使用受检异常，对编程错误使用运行时异常  

### 第71条：避免不必要地使用受检异常  

### 第72条：优先使用标准的异常  

### 第73条：抛出与抽象对应的异常  

### 第74条：每个方法抛出的所有异常都要建立文档  

### 第75条：在细节消息中包含失败-捕获信息  

### 第76条：努力使失败保持原子性  

### 第77条：不要忽略异常  

## 第11章　并发  

### 第78条：同步访问共享的可变数据  

### 第79条：避免过度同步  

### 第80条：executor、task和stream优先于线程  

### 第81条：并发工具优先于wait和notify  

### 第82条：线程安全性的文档化  

### 第83条：慎用延迟初始化  

### 第84条：不要依赖于线程调度器  

### 第12章　序列化  

### 第85条：其他方法优先于Java序列化  

### 第86条：谨慎地实现Serializable接口  

### 第87条：考虑使用自定义的序列化形式  

### 第88条：保护性地编写readObject方法  

### 第89条：对于实例控制，枚举类型优先于readResolve  

### 第90条：考虑用序列化代理代替序列化实例  

 





