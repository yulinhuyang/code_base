### 1  tricks

[C++开源矩阵计算工具——Eigen的简单用法（一）](https://blog.csdn.net/houjixin/article/details/8490941)

[动态存储区、静态存储区、堆和栈的区别](https://blog.csdn.net/chen1083376511/article/details/54930191)





### 2  notes

**static**

static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。


**程序的内存分配**

栈区(stack):由编译器自动分配释放，存放函数的参数值，局部变量等值。

堆区(heap):堆允许程序在运行时动态地申请某个大小的内存。一般由程序员分配释放。

数据段：

只读数据段：一般是const修饰的变量以及程序中使用的文字常量一般会存放在只读数据段中。

已初始化的读写数据段：一般为已经初始化的全局变量，已经初始化的静态局部变量(static修饰的已经初始化的变量)

未初始化段（BSS）：BSS段通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。


常量区（特殊的常量存储区，属于静态存储区）

　　1) 常量占用内存,只读状态,决不可修改
　
　　3) 常量字符串就是放在这里的，程序结束后由系统释放

程序的内存分配：

  一个由C/C++编译的程序占用的内存分为以下几个部分  
  
        1、栈区（stack）：由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。其  操作方式类似于数据结构中的栈。  
        
        2、堆区（heap） ：一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
        
        3、全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，   未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。  
        
         4、文字常量区：常量字符串就是放在这里的程序结束后由系统释放  
         
         5、程序代码区：存放函数体的二进制代码。


**引用与指针**

引用是别名

构造函数和析构函数不能抛出异常，不要调用虚函数。

use—A：类的依赖关系


**C++多态**

C++支持两种多态性：编译时多态性，运行时多态性。

　　a.编译时多态性：通过重载函数实现。
  
　　b.运行时多态性：通过虚函数实现。


1 静态多态（重载，模板）  是在编译的时候，就确定调用函数的类型。

2 动态多态（覆盖，虚函数实现）  在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。

虚函数实现原理：虚函数表和虚函数指针。

纯虚函数： virtual int fun() = 0;

函数的运行版本由实参决定，在运行时选择函数的版本，所以动态绑定又称为运行时绑定。

当编译器遇到一个模板定义时，它并不生成代码。只有当实例化出模板的一个特定版本时，编译器才会生成代码。

**类型转换**

继承机制中对象之间如何转换？指针和引用之间如何转换？

向上类型转换：将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。

向下类型转换：将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。

**拷贝与移动**

C++11之前，对象的拷贝控制由三个函数决定：拷贝构造函数（Copy Constructor）、拷贝赋值运算符（Copy Assignment operator）和析构函数（Destructor）。

C++11之后，新增加了两个函数：移动构造函数（Move Constructor）和移动赋值运算符（Move Assignment operator）。

区分构造和赋值：构造函数与赋值运算符的区别是，构造函数在创建或初始化对象的时候调用，而赋值运算符在更新一个对象的值时调用。

区分拷贝与移动：用对象a初始化对象b，拷贝构造函数，实际上就是把a对象的内容复制一份到b中。这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷

https://www.jianshu.com/p/f5d48a7f5a52

```cpp
class A {
public:
    int x;
    A(int x) : x(x)
    {
        cout << "Constructor" << endl;
    }
    A(A& a) : x(a.x)
    {
        cout << "Copy Constructor" << endl;
    }
    A& operator=(A& a)
    {
        x = a.x;
        cout << "Copy Assignment operator" << endl;
        return *this;
    }
    A(A&& a) : x(a.x)
    {
        cout << "Move Constructor" << endl;
    }
    A& operator=(A&& a)
    {
        x = a.x;
        cout << "Move Assignment operator" << endl;
        return *this;
    }
};
```

**C语言的编译链接过程**

源代码－－>预处理－－>编译－－>优化－－>汇编－－>链接-->可执行文件

预编优化，汇链执

预处理：读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。包括**宏定义替换、条件编译指令、头文件包含指令、特殊符号**。 预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。i预处理后的c文件，.ii预处理后的C++文件。

编译阶段：编译程序所要作得工作就是通过**词法分析和语法分析**，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或**汇编代码.s文件。**

汇编过程：汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的**机器语言代码。.o目标文件**

链接阶段：链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。

